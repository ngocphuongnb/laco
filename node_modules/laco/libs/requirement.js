"use strict";

const net = require('net');
const _ = require('underscore');
const async = require('async');
const mongoose = require('mongoose');
const mongooseAutoIncrement = require('mongoose-auto-increment');
const logger = require('./logger');
const eventEmitter = require('./eventEmitter');

let checkPort = port => {
    return new Promise((resolve, reject) => {
        var server = net.createServer(function(socket) {
            socket.write('Echo server\r\n');
            socket.pipe(socket);
        });

        server.listen(port, '127.0.0.1');
        server.on('error', function (e) {
            logger.error('Port already in used');
            return reject('checkPort: ' + e);
        });
        server.on('listening', function (e) {
            server.close();
            logger.info(`Port ${port} is free`);
            return resolve();
        });
    });
};

let check = (obj, callback) => {
    let _obj = _.extend({
        port: 1906
    }, obj);
    checkPort(_obj.port).then(() => {
        return callback(null);
    }).catch((err) => {
        return callback(err);
    });
};


let dbInit = dbInfo => {
    logger.info('Opening DB connection...');
    mongoose.connect(dbInfo.uri, dbInfo.options);
    mongoose.connection.on('connected', () => {
        logger.info('Connected to db');
        eventEmitter.emit('app.wakeup');
    });
    mongoose.connection.on('error', err => {
        logger.error('DB connection error: ' + err);        
        eventEmitter.emit('app.shutdown');
    });
    mongoose.connection.on('disconnected', err =>{
        logger.error('Disconnected to db: ' + err);
        eventEmitter.emit('app.sleep');
    });
    mongoose.connection.once('open', () => {
        logger.info('DB connection opened');
        mongooseAutoIncrement.initialize(mongoose.connection);
        eventEmitter.emit('app.start');
    });
};

exports.check = check;
exports.dbInit = dbInit;