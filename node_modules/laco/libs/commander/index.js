'use strict';

const _ = require('lodash');
const logger = require('../logger');
const helper = require('../helper');
const EventEmitter = require('../EventEmitter');

class Commander extends EventEmitter {
    constructor(laco) {
        super();
        this.laco = laco;
        this.argv = process.argv;
        this.registeredCommands = {
            start: {
                description: 'Start current application'
            },
            help: {
                description: 'Show help information'
            }
        };
        this.helps = {
            start: 'Start current application',
            help: 'Show help information',
        };
        this.currentCommand = null;

        this.argv.splice(0, 2);
        this.laco.once('ready', () => {
            this.map();
        });

        this.commandDefault = {
            name: null,
            alias: null,
            description: null,
            options: []
        }

        this.commandOptionDefault = {
            name: null,
            alias: null,
            description: null,
            type: null
        }
    }

    map() {
        let userCommand = this.argv[0] || 'start';
        this.currentCommand = userCommand;

        if (userCommand == 'start') {
            return;
        }
        if (!this.registeredCommands[userCommand]) {
            console.log('Invalid command, check supported commands:');
            return this.help();
        }

        if (userCommand == '-h' || userCommand == 'help') {
            return this.help(this.argv[1] || null);
        }


        this.executeCommand();
    }

    help(cmd = null) {
        if (!cmd || !this.helps[cmd]) {
            console.log('\n  Usage: ./laco [command] [options]');
            console.log('\n  Type: ./laco help [command] for more detail');
            console.log('\n  Commands:\n');
            let helpOutput = [];
            for (var cmdName in this.helps) {
                helpOutput.push(`    ${cmdName.padEnd(20)}: ${this.helps[cmdName]}`);
            }
            console.log(helpOutput.join(`\n`) + '\n');
            return;
        }

        console.log(`\n  Usage: ./laco ${cmd} [options]`);
        console.log('\n  Options:\n');
        let helpOutput = [];
        for (var i = 0; i < this.registeredCommands[cmd].options.length; i++) {
            let option = this.registeredCommands[cmd].options[i];
            helpOutput.push(`    ${option.name.padEnd(20)}: ${option.description || ''}`);
        }
        console.log(helpOutput.join(`\n`) + '\n');
        return;
    }

    isCommand(cmd) {
        return this.currentCommand == cmd;
    }

    executeCommand() {
        let option = this.argv[1] || 'exec';
        let optionArgv = this.argv;
        optionArgv.splice(0, 2);

        let CommandHandler = this.registeredCommands[this.currentCommand].handler;
        let commandObj = new CommandHandler();
        let optionCMD = commandObj[option];
        optionCMD(this.laco.subAppManager.registeredApps, optionArgv);
    }

    register(cmds) {
        if (!_.isArray(cmds)) {
            cmds = [cmds];
        }

        let caller = helper.caller();

        for (var i = 0; i < cmds.length; i++) {
            let cmd = _.merge(this.commandDefault, cmds[i]);
            if (!cmd.name) {
                logger.error('[Commander.regis] Invalid command: ', { cmd, caller });
            } else {
                logger.info(`[Commander.regis] Registering command: ${cmd.name}`);
                this.helps[cmd.name] = cmd.description || '';
                cmd.caller = caller;
                this.registeredCommands[cmd.name] = cmd;
            }
        }
    }
}

module.exports = Commander;