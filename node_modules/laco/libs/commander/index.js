'use strict';

const _ = require('lodash');
const logger = require('../logger');
const helper = require('../helper');
const EventEmitter = require('../EventEmitter');

class Commander extends EventEmitter {
    constructor(laco) {
        super();
        this.laco = laco;
        this.argv = process.argv;
        this.registeredCommands = {
            start: {
                description: 'Start current application'
            },
            help: {
                description: 'Show help information'
            }
        };
        this.helps = {
            start: 'Start current application',
            help: 'Show help information',
        };
        this.currentCommand = null;

        this.argv.splice(0, 2);
        this.laco.once('ready', () => {
            this.map();
        });

        this.commandDefault = {
            name: null,
            alias: null,
            description: null,
            options: []
        }

        this.commandOptionDefault = {
            name: null,
            alias: null,
            description: null,
            type: null
        }
    }

    map() {
        let userCommand = this.argv[0] || 'start';
        this.currentCommand = userCommand;

        if (userCommand == 'start') {
            return;
        }
        if (!this.registeredCommands[userCommand]) {
            this.out('Invalid command, check supported commands:');
            return this.help();
        }

        if (userCommand == '-h' || userCommand == 'help') {
            return this.help(this.argv[1] || null);
        }


        this.executeCommand();
    }

    out(msg = '') {
        process.stdout.write(`  ${msg}\n`);
    }

    help(cmd = null) {
        this.out();
        if (!cmd || !this.helps[cmd]) {
            this.out('Usage: ./laco [command] [options]');
            this.out('Try ./laco help [command] for more detail\n');
            this.out('Commands:');
            let helpOutput = [];
            for (var cmdName in this.helps) {
                this.out(`  ${cmdName.padEnd(20)}: ${this.helps[cmdName]}`);
            }
            this.out();
            return;
        }

        this.out(`Usage: ./laco ${cmd} [options]\n`);
        this.out('Options:');
        let helpOutput = [];
        for (var i = 0; i < this.registeredCommands[cmd].options.length; i++) {
            let option = this.registeredCommands[cmd].options[i];
            this.out(`  ${option.name.padEnd(20)}: ${option.description || ''}`);
        }
        this.out();
        return;
    }

    isCommand(cmd) {
        return this.currentCommand == cmd;
    }

    executeCommand() {
        let option = this.argv[1] || 'exec';
        let optionArgv = this.argv;
        optionArgv.splice(0, 2);

        let commandObj = this.registeredCommands[this.currentCommand];

        if (!_.isFunction(commandObj[option])) {
            logger.error('[Commander.regis] Invalid command handler: ', { option, caller: commandObj.caller });
            return;
        }
        this.out();
        this.out('Laco version: ' + this.laco.version);
        this.out((commandObj.label || commandObj.name) + ' version: ' + commandObj.version);
        commandObj[option](optionArgv);
    }

    register(cmds) {
        if (!_.isArray(cmds)) {
            cmds = [cmds];
        }

        let caller = helper.caller();

        for (var i = 0; i < cmds.length; i++) {
            let cmd = cmds[i];
            if (!cmd.name) {
                logger.error('[Commander.regis] Invalid command: ', { cmd, caller });
            } else {
                logger.info(`[Commander.regis] Registering command: ${cmd.name}`);
                this.helps[cmd.name] = cmd.description || '';
                cmd.caller = caller;
                this.registeredCommands[cmd.name] = cmd;
            }
        }
    }
}

module.exports = Commander;