"use strict";
const _ = require('underscore');
const async = require('async');
const g = lacoLib('./libs/global');
const logger = lacoLib('./libs/logger');
const helper = lacoLib('./libs/helper');

class Provider {
    constructor() {
        let caller = helper.caller();
        this.providerClassName = caller.getFunctionName();
        this.modelName = this.providerClassName.replace('Provider', '').toLowerCase();
        this.model = g.models[this.modelName] || null;

        if(!this.model) {
            logger.error('[Model.Class] model not found: ' + this.modelName);
        }

        this.defaultFilterObj = {
            sortBy: '-_id',
            limit: 50,
            page: 1
        }

        this.conditionalBuilder = null;
        this.itemTransfomer = null;
    }

    defaultFilter() {
        return this.defaultFilterObj;
    }

    queryBuilder(filter) {
        filter = _.extend(this.defaultFilter(), filter);
        if(!filter.sortBy) filter.sortBy = '-_id';
            let softType = filter.sortBy[0] == '+' ? '1' : '-1';
            filter.sortBy = filter.sortBy.substring(1);
            if(filter.page < 1) filter.page = 1;

            let sortQuery = {};
            sortQuery[filter.sortBy] = softType;

            let searchQuery = {};
            let conditions = _.isFunction(this.conditionalBuilder) ? this.conditionalBuilder(filter) : [];

            if(!!conditions.length) searchQuery['$and'] = conditions;

            let limit = filter.limit;
            let skip = (filter.page - 1)*filter.limit;
            return {searchQuery, sortQuery, limit, skip};
    }

    result(findPromise) {
        return !_.isFunction(this.itemTransfomer) ? findPromise :
            new Promise(
                (resolve, reject) => findPromise.then(
                    items => resolve(
                        _.map(items, item => this.itemTransfomer(item))
                    )
                )
                .catch(e => reject(e))
            );
    }

    add(data) {
        let dataObj = new this.model(data);
        return dataObj.save();
    }

    get(filter) {
        let qb = this.queryBuilder(filter);
        let findPromise = this.model.find(qb.searchQuery).sort(qb.sortQuery).limit(qb.limit).skip(qb.skip).lean().exec();

        return this.result(findPromise);
    }

    count(filter) {
        let qb = this.queryBuilder(filter);
        return this.model.count(qb.searchQuery).exec();
    }

    paging(pageNumber) {
        let filterObj = this.defaultFilter();
        if(_.isNumber(pageNumber)) filterObj.page = pageNumber;
        if(_.isObject(pageNumber)) filterObj = _.extend(filterObj, pageNumber);

        return new Promise((resolve, reject) => {
            Promise.all([
                this.get(filterObj),
                this.count(filterObj)
            ]).then(data => {
                let totalItems = data[1] || 0;
                let items = _.isArray(data[0]) ? data[0] : [];
                let paging = {
                    total: totalItems,
                    page: filterObj.page,
                    limit: filterObj.limit
                };

                return resolve({items, paging});
            }).catch(e => {
                logger.error('[Lib.provider.paging] Error fetching paged media data:');
                logger.error(e);
                return reject(e.message);
            });
        });
    }

    withIds(ids) {
        if(!_.isArray(ids)) ids = [ids];
        ids = _.map(ids, id => 1*id);
        let findMethod = ids[1] ? 'find' : 'findOne';
        let findPromise = this.model[findMethod]({intId: id}).exec();

        return this.result(findPromise);
    }
}

module.exports = Provider;