"use strict";
const mediaModel = require('./model');
const _ = require('underscore');
const async = require('async');
const g = lacoLib('./libs/global');
const logger = lacoLib('./libs/logger');

let fileTypes = {
    document: ['doc', 'docx', 'ppt', 'pptx', 'xls', 'xlsx', 'pdf', 'txt', 'rtf', 'chm'],
    image: ['jpg', 'jpeg', 'png', 'gif', 'bmp'],
    video: ['mp4', 'mpg', 'mpeg', 'kmv', 'flv', 'webm'],
    audio: ['mp3', 'wav', 'm4a', 'flac'],
    archive: ['zip', 'rar', 'tgz', 'tar', 'gz'],
    application: ['exe', 'dll', 'dmg']
};

let defaultFilter = {
    sortBy: '-date',
    limit: 50,
    page: 1,
    term: '',
    types: ['all']
}

let queryBuilder = filter => {
    filter = _.extend(_.clone(defaultFilter), filter);
    if(!filter.sortBy) filter.sortBy = '-date';
        let softType = filter.sortBy[0] == '+' ? '1' : '-1';
        filter.sortBy = filter.sortBy.substring(1);
        if(filter.page < 1) filter.page = 1;

        let sortQuery = {};
        sortQuery[filter.sortBy] = softType;

        let searchQuery = {};
        let conditions = [];
        if(filter.term && _.isString(filter.term)) {
            conditions.push({source: new RegExp(filter.q, 'gi')});
            conditions.push({alt: new RegExp(filter.q, 'gi')});
            conditions.push({name: new RegExp(filter.q, 'gi')});
            conditions.push({description: new RegExp(filter.q, 'gi')});
        }

        if(filter.types.indexOf('all') == -1) {
            let searchFileExts = [];
            _.each(filter.types, type => {
                if(fileTypes[type] && _.isArray(fileTypes[type]))
                    searchFileExts = _.union(searchFileExts, fileTypes[type]);
            });
            conditions.push({
                source: {$regex: new RegExp('(.*)\.(' + searchFileExts.join('|') + ')$', 'i')}
            });
        }
        if(!!conditions.length) searchQuery['$and'] = conditions;

        let limit = filter.limit;
        let skip = (filter.page - 1)*filter.limit;
        return {searchQuery, sortQuery, limit, skip};
}

let add = mediaData => {
    let _media = new g.models.media(mediaData);
    return _media.save();
}

let get = filter => {
    let qb = queryBuilder(filter);
    return g.models.media.find(qb.searchQuery).sort(qb.sortQuery).limit(qb.limit).skip(qb.skip).lean().exec();
}

let count = filter => {
    let qb = queryBuilder(filter);
    return g.models.media.count(qb.searchQuery).exec();
}

let paging = pageNumber => {
    let mediaFilter = _.clone(defaultFilter);
    if(_.isNumber(pageNumber)) mediaFilter.page = pageNumber;
    if(_.isObject(pageNumber)) mediaFilter = _.extend(mediaFilter, pageNumber);

    return new Promise((resolve, reject) => {
        Promise.all([get(mediaFilter), count(mediaFilter)]).then(data => {
            let totalMedias = data[1] || 0;
            let mediaItems = _.isArray(data[0]) ? data[0] : [];

            return resolve({
                medias: mediaItems,
                paging: {
                    total: totalMedias,
                    page: mediaFilter.page,
                    limit: mediaFilter.limit
                }
            });
        }).catch(e => {
            logger.error('[Lib.media.provider.paging] Error fetching paged media data:');
            logger.error(e);
            return reject(e.message);
        });
    });
}

let withIds = ids => {
    if(!_.isArray(ids)) ids = [ids];
    ids = _.map(ids, id => 1*id);
    let findMethod = ids[1] ? 'find' : 'findOne';
    return mediaModel[findMethod]({intId: id}).exec();
}

exports.model = mediaModel;
exports.get = get;
exports.paging = paging;
exports.add = add;
exports.withIds = withIds;