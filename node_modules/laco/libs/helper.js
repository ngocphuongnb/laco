'use strict';

const path = require('path');

global.lacoLib = name => {
    let lacoLocation = path.dirname(require.resolve('laco'));
    return require(path.join(lacoLocation, name));
}

String.prototype.trimChar = function(charToRemove) {
    let str = this;
    while (str.charAt(0) == charToRemove) {
        str = str.substring(1);
    }
    while (str.charAt(str.length - 1) == charToRemove) {
        str = str.substring(0, str.length - 1);
    }
    return str;
}

// https://github.com/uxitten/polyfill/blob/master/string.polyfill.js
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart
if (!String.prototype.padStart) {
    String.prototype.padStart = function padStart(targetLength, padString) {
        targetLength = targetLength >> 0; //truncate if number or convert non-number to 0;
        padString = String((typeof padString !== 'undefined' ? padString : ' '));
        if (this.length > targetLength) {
            return String(this);
        } else {
            targetLength = targetLength - this.length;
            if (targetLength > padString.length) {
                padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
            }
            return padString.slice(0, targetLength) + String(this);
        }
    };
}

// https://github.com/uxitten/polyfill/blob/master/string.polyfill.js
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd
if (!String.prototype.padEnd) {
    String.prototype.padEnd = function padEnd(targetLength, padString) {
        targetLength = targetLength >> 0; //floor if number or convert non-number to 0;
        padString = String((typeof padString !== 'undefined' ? padString : ' '));
        if (this.length > targetLength) {
            return String(this);
        } else {
            targetLength = targetLength - this.length;
            if (targetLength > padString.length) {
                padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
            }
            return String(this) + padString.slice(0, targetLength);
        }
    };
}

const errorStackInfo = stack => {
    let traces = [];
    while (stack.length) {
        let callerfile = stack.shift();
        traces.push({
            file: callerfile.getFileName().replace(process.env.APP_ROOT, ''),
            method: callerfile.getFunctionName(),
            line: callerfile.getLineNumber(),
            column: callerfile.getColumnNumber()
        });
    }
    return traces;
}

const caller = () => {
    try {
        let err = new Error();
        let callerfile;
        let currentfile;

        let _prepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = (err, stack) => stack;

        let _stack = err.stack;
        err.stack.shift();
        currentfile = err.stack.shift();

        while (err.stack.length) {
            callerfile = err.stack.shift();
            if (currentfile !== callerfile) {
                Error.prepareStackTrace = _prepareStackTrace;
                //callerfile.stack = errorStackInfo(_stack);
                // return callerfile;
                return {
                    dir: path.dirname(callerfile.getFileName()),
                    baseDir: path.dirname(callerfile.getFileName()).replace(process.env.APP_ROOT, ''),
                    file: callerfile.getFileName().replace(process.env.APP_ROOT, ''),
                    method: callerfile.getFunctionName(),
                    line: callerfile.getLineNumber(),
                    column: callerfile.getColumnNumber()
                }
            }
        }
    } catch (err) {
        logger.error('[helper.caller] Error finding caller', err);
    }
    return undefined;
};

const isFileExisted = filePath => {
    try {
        require.resolve(filePath);
        return true;
    } catch (ex) {
        return false;
    }
};

exports.errorStackInfo = errorStackInfo;
exports.caller = caller;
exports.isFileExisted = isFileExisted;