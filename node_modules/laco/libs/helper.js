'use strict';

const path = require('path');

String.prototype.trimChar = function(charToRemove) {
    let str = this;
    while (str.charAt(0) == charToRemove) {
        str = str.substring(1);
    }
    while (str.charAt(str.length - 1) == charToRemove) {
        str = str.substring(0, str.length - 1);
    }
    return str;
}

const errorStackInfo = stack => {
    let traces = [];
    while (stack.length) {
        let callerfile = stack.shift();
        traces.push({
            file: callerfile.getFileName().replace(process.env.APP_ROOT, ''),
            method: callerfile.getFunctionName(),
            line: callerfile.getLineNumber(),
            column: callerfile.getColumnNumber()
        });
    }
    return traces;
}

const caller = () => {
    try {
        let err = new Error();
        let callerfile;
        let currentfile;

        let _prepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = (err, stack) => stack;

        let _stack = err.stack;
        err.stack.shift();
        currentfile = err.stack.shift();

        while (err.stack.length) {
            callerfile = err.stack.shift();
            if (currentfile !== callerfile) {
                Error.prepareStackTrace = _prepareStackTrace;
                //callerfile.stack = errorStackInfo(_stack);
                // return callerfile;
                return {
                    dir: path.dirname(callerfile.getFileName()),
                    baseDir: path.dirname(callerfile.getFileName()).replace(process.env.APP_ROOT, ''),
                    file: callerfile.getFileName().replace(process.env.APP_ROOT, ''),
                    method: callerfile.getFunctionName(),
                    line: callerfile.getLineNumber(),
                    column: callerfile.getColumnNumber()
                }
            }
        }
    } catch (err) {
        logger.error('[helper.caller] Error finding caller', err);
    }
    return undefined;
};

exports.errorStackInfo = errorStackInfo;
exports.caller = caller;