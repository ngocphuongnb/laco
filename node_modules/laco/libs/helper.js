'use strict';

const path = require('path');
const crypto = require('crypto');

const CRYPTO_DEFAULT_ALGORITHM = 'aes-256-ctr';


global.lacoLib = name => {
    let lacoLocation = path.dirname(require.resolve('laco'));
    return require(path.join(lacoLocation, name));
}

String.prototype.trimChar = function(charToRemove) {
    let str = this;
    while (str.charAt(0) == charToRemove) {
        str = str.substring(1);
    }
    while (str.charAt(str.length - 1) == charToRemove) {
        str = str.substring(0, str.length - 1);
    }
    return str;
}

// https://github.com/uxitten/polyfill/blob/master/string.polyfill.js
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart
if (!String.prototype.padStart) {
    String.prototype.padStart = function padStart(targetLength, padString) {
        targetLength = targetLength >> 0; //truncate if number or convert non-number to 0;
        padString = String((typeof padString !== 'undefined' ? padString : ' '));
        if (this.length > targetLength) {
            return String(this);
        } else {
            targetLength = targetLength - this.length;
            if (targetLength > padString.length) {
                padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
            }
            return padString.slice(0, targetLength) + String(this);
        }
    };
}

// https://github.com/uxitten/polyfill/blob/master/string.polyfill.js
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd
if (!String.prototype.padEnd) {
    String.prototype.padEnd = function padEnd(targetLength, padString) {
        targetLength = targetLength >> 0; //floor if number or convert non-number to 0;
        padString = String((typeof padString !== 'undefined' ? padString : ' '));
        if (this.length > targetLength) {
            return String(this);
        } else {
            targetLength = targetLength - this.length;
            if (targetLength > padString.length) {
                padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
            }
            return String(this) + padString.slice(0, targetLength);
        }
    };
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
if (!String.prototype.startsWith) {
    String.prototype.startsWith = function(search, pos) {
        return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    };
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
if (!String.prototype.endsWith) {
    String.prototype.endsWith = function(search, this_len) {
        if (this_len === undefined || this_len > this.length) {
            this_len = this.length;
        }
        return this.substring(this_len - search.length, this_len) === search;
    };
}

const errorStackInfo = stack => {
    let traces = [];
    while (stack.length) {
        let callerfile = stack.shift();
        traces.push({
            file: callerfile.getFileName().replace(process.env.APP_ROOT, ''),
            method: callerfile.getFunctionName(),
            line: callerfile.getLineNumber(),
            column: callerfile.getColumnNumber()
        });
    }
    return traces;
}

const caller = () => {
    try {
        let err = new Error();
        let callerfile;
        let currentfile;

        let _prepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = (err, stack) => stack;

        let _stack = err.stack;
        err.stack.shift();
        currentfile = err.stack.shift();

        while (err.stack.length) {
            callerfile = err.stack.shift();
            if (currentfile !== callerfile) {
                Error.prepareStackTrace = _prepareStackTrace;
                //callerfile.stack = errorStackInfo(_stack);
                // return callerfile;
                return {
                    dir: path.dirname(callerfile.getFileName()),
                    baseDir: path.dirname(callerfile.getFileName()).replace(process.env.APP_ROOT, ''),
                    file: callerfile.getFileName().replace(process.env.APP_ROOT, ''),
                    method: callerfile.getFunctionName(),
                    line: callerfile.getLineNumber(),
                    column: callerfile.getColumnNumber()
                }
            }
        }
    } catch (err) {
        logger.error('[helper.caller] Error finding caller', err);
    }
    return undefined;
};

const isFileExisted = filePath => {
    try {
        require.resolve(filePath);
        return true;
    } catch (ex) {
        return false;
    }
};

// password: 32 chars

const encrypt = (
    text,
    password = process.env.CRYPTO_DEFAULT_PASSWORD,
    algorithm = CRYPTO_DEFAULT_ALGORITHM,
    iv_length = parseInt(process.env.CRYPTO_IV_LENGTH)
) => {
    if (typeof text == 'object') {
        text = JSON.stringify(text);
    }

    let iv = crypto.randomBytes(iv_length);
    let cipher = crypto.createCipheriv('aes-256-cbc', new Buffer(password), iv);
    let encrypted = cipher.update(text);

    encrypted = Buffer.concat([encrypted, cipher.final()]);

    return iv.toString('hex') + ':' + encrypted.toString('hex');
}

const decrypt = (
    text,
    password = process.env.CRYPTO_DEFAULT_PASSWORD,
    algorithm = CRYPTO_DEFAULT_ALGORITHM,
    iv_length = parseInt(process.env.CRYPTO_IV_LENGTH)
) => {
    let textParts = text.split(':');
    let iv = new Buffer(textParts.shift(), 'hex');
    let encryptedText = new Buffer(textParts.join(':'), 'hex');
    let decipher = crypto.createDecipheriv('aes-256-cbc', new Buffer(password), iv);
    let decrypted = decipher.update(encryptedText);

    decrypted = Buffer.concat([decrypted, decipher.final()]);

    let dec = decrypted.toString();

    try {
        dec = JSON.parse(dec);
    } catch (e) {

    }
    return dec;
}

exports.errorStackInfo = errorStackInfo;
exports.caller = caller;
exports.isFileExisted = isFileExisted;
exports.encrypt = encrypt;
exports.decrypt = decrypt;