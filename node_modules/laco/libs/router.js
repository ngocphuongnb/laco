'use strict';

const _ = require('lodash');
const logger = require('./logger');
const httpMethods = ['get', 'post', 'put', 'delete', 'head', 'all', 'patch', 'trace', 'options', 'connect'];

class Router {
    constructor(namespace, app) {
        this.app = app;
        this.namespace = namespace;
        this.registeredRoutes = [];
        this.registeredMiddlewares = {};
        this.registeredParams = {};
    }

    /**
     * Register route(s) and it's handler
     * @param {[object]} routeList 
     */
    register(routeList) {
        if (!_.isArray(routeList)) {
            routeList = [routeList];
        }
        _.each(routeList, routeObj => {
            if (!routeObj.name ||
                !routeObj.path ||
                (!routeObj.get &&
                    !routeObj.post &&
                    !routeObj.head &&
                    !routeObj.delete &&
                    !routeObj.put &&
                    !routeObj.all
                )
            ) {
                return logger.error(`[Router.register] [${this.namespace}] Invalid route: `, routeObj);
            }

            if (!routeObj.label) {
                routeObj.label = routeObj.name;
            }

            logger.info(`[Router.register] [${this.namespace}] Registering route: \x1b[32m${routeObj.label}\x1b[0m`);
            let checkRoute = _.filter(this.registeredRoutes, {
                name: routeObj.name
            }).length;
            if (checkRoute) {
                return logger.error(`[Router.register]  [${this.namespace}] Route existed (name): ${routeObj.name}`);
            }

            let routesWithSamePath = _.filter(this.registeredRoutes, {
                path: routeObj.path
            });
            if (routesWithSamePath.length) {
                let duplicatedMethods = [];
                _.each(routesWithSamePath, existedRoute => {
                    _.each(httpMethods, method => {
                        if (existedRoute[method] && routeObj[method]) {
                            duplicatedMethods.push(method.toUpperCase());
                        }
                    });
                });
                if (duplicatedMethods.length) {
                    return logger.error(`[Router.register] [${this.namespace}] Route existed (path, method): [${duplicatedMethods.join('|')}] ${routeObj.path}`);
                }
            }
            this.registeredRoutes.push(routeObj);
        });
    }

    /**
     * UnRegister route(s) by it's name
     * @param {[string]} routeNames 
     */
    deleteRoutes(routeNames) {
        if (!_.isArray(routeNames)) {
            routeNames = [routeNames];
        }
        logger.info(`[Router.delete] [${this.namespace}] Deleteing routes: ${routeNames.join(',')}`);
        this.registeredRoutes = _.clone(this.registeredRoutes).filter(routeobj => {
            return !routeNames.includes(routeobj.name);
        });
    }

    get() {
        return this.registeredRoutes;
    }

    /**
     * @description get the index of the route given by name
     * @param {string} routeName
     * @return {integer} index of the route in this.registeredRoutes array
     */

    getRouteIndexByName(routeName) {
        let routeIndex = _.findIndex(this.registeredRoutes, routeObj => {
            return routeObj.name == routeName;
        });
        return routeIndex;
    }

    /**
     * Attach other request method handler to an existed route
     * @param {string} routeName 
     * @param {string} method 
     * @param {function(req, res, next)} handler 
     */
    attach(routeName, method, handler) {
        let routeIndex = _.findIndex(this.registeredRoutes, routeObj => {
            return routeObj.name == routeName;
        });

        if (routeIndex == null) {
            return logger.error(`[Router.attach] [${this.namespace}] Route not found: ${routeName}`);
        }
        if (this.registeredRoutes[routeIndex][method]) {
            return logger.error(`[Router.attach] [${this.namespace}] Attach method existed: [${method}] ${routeName}, try to detach it first!`);
        }
        this.registeredRoutes[routeIndex][method] = handler;
    }

    /**
     * Detach method handler from a route
     * @param {string} routeName 
     * @param {string} method 
     */
    detach(routeName, method) {
        let routeIndex = getRouteIndexByName(routeName);

        if (routeIndex == null) {
            return logger.error(`[Router.detach] [${this.namespace}] Route not found: ${routeName}`);
        }
        if (!this.registeredRoutes[routeIndex][method]) {
            return logger.error(`[Router.detach] [${this.namespace}] Detach method not found: [${method}] ${routeName}`);
        }
        delete this.registeredRoutes[routeIndex][method];
    }

    /**
     * @description attach middware to a route
     * @param {array of object} middlewareList
     * @return {null} does't return any thing 
     */
    middleware(middlewareList) {
        if (_.isObject(middlewareList)) {
            middlewareList = [middlewareList];
        }
        _.each(middlewareList, mdw => {
            if (!_.isString(mdw.route)) {
                return logger.error('[Router.middleware] [${this.namespace}] invalid route name!');
            }
            let routeIndex = getRouteIndexByName(mdw.route);
            if (routeIndex == null) {
                return logger.error(`[Router.middleware] [${this.namespace}] Route not found: ${mdw.route}`);
            }

            if (!this.registeredMiddlewares[mdw.route]) {
                this.registeredMiddlewares[mdw.route] = {};
                _.each(httpMethods, method => this.registeredMiddlewares[mdw.route][method] = []);
            }
            _.each(httpMethods, method => {
                if (!_.isArray(this.registeredMiddlewares[mdw.route][method])) {
                    this.registeredMiddlewares[mdw.route][method] = [];
                }
                if (_.isFunction(mdw[method])) {
                    this.registeredMiddlewares[mdw.route][method].push(mdw[method]);
                }
            });
        });
    }

    getMiddlewares() {
        return this.registeredMiddlewares;
    };

    /**
     * Add handler for a custom params
     * @param {array of object} paramList 
     */
    param(paramList) {
        for (var paramName in paramList) {
            let paramHandler = paramList[paramName];
            if (this.registeredParams[paramName]) {
                logger.error(`[Router.param] [${this.namespace}] Param existed (by name): ${paramName}`);
            } else {
                logger.info(`[Router.param] [${this.namespace}] Success register param handler: ${paramName}`);
                this.registeredParams[paramName] = paramHandler;
            }
        }
    }

    /**
     * Fire an action to check which route is matched
     * @param {Laco app instance} app 
     */
    dispatch(_app = null) {
        let app = _app || this.app;
        logger.info(`[Router.dispatch] [${this.namespace}] Dispatching...`)
        let routerNaming = (req, res, next) => {
            let routePattern = (req.route && req.route.path) ? req.route.path : null;
            let routesWithPattern = _.filter(this.registeredRoutes, {
                path: routePattern
            });
            if (!!routesWithPattern.length) {
                req.route = Object.assign(req.route, routesWithPattern[0]);
            }
            next();
        };

        let _registeredRoutes = _.map(this.registeredRoutes, routeObj => {
            if (!_.isNumber(routeObj.priority)) {
                routeObj.priority = 0;
            }
            return routeObj;
        });
        _registeredRoutes = _.sortBy(_registeredRoutes, 'priority').reverse();
        _.each(_registeredRoutes, routeObj => {
            _.each(httpMethods, method => {
                if (_.isFunction(routeObj[method])) {
                    // if a route has middleware then call middleware before execute route action;
                    if (this.registeredMiddlewares[routeObj.name] && this.registeredMiddlewares[routeObj.name][method]) {
                        let routeMiddlewares = _.clone(this.registeredMiddlewares[routeObj.name][method]);
                        routeMiddlewares.push(routeObj[method]);
                        app[method](routeObj.path, routerNaming, routeMiddlewares);
                    } else {
                        app[method](routeObj.path, routerNaming, routeObj[method]);
                    }
                }
            });
        });

        for (var paramName in this.registeredParams) {
            let paramHandler = this.registeredParams[paramName];
            if (_.isFunction(paramHandler)) {
                app.param(paramName, paramHandler);
            } else logger.error(`[Router.param] [${this.namespace}] Invalid param handler: ${paramName}`, paramHandler);
        }
    }
}

module.exports = Router;