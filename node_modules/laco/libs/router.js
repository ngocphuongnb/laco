"use strict";

const _ = require('underscore');
const logger = require('./logger');

const httpMethods = ['get', 'post', 'put', 'delete', 'head', 'all', 'patch', 'trace', 'options', 'connect'];
let registeredRoutes = [];
let registeredMiddlewares = {};

let register = routeList => {
    if(!_.isArray(routeList)) routeList = [routeList];
    _.each(routeList, routeObj => {
        if(
            !routeObj.label || !routeObj.name || !routeObj.path ||
            (!routeObj.get && !routeObj.post && !routeObj.head && !routeObj.delete && !routeObj.put && !routeObj.all)
        ) return logger.error('[Router.register] Invalid route: ' + routeObj);

        logger.info('Registering route: ' + routeObj.label);
        if(!!_.where(registeredRoutes, {name:routeObj.name}).length)
            return logger.error('[Router.register] Route existed (by name): ' + routeObj.name);

        let routesWithSamePath = _.where(registeredRoutes, {path:routeObj.path});
        if(!!routesWithSamePath.length) {
            let duplicatedMethods = [];
            _.each(routesWithSamePath, existedRoute => {
                _.each(httpMethods, method => {
                    if(existedRoute[method] && routeObj[method]) duplicatedMethods.push(method.toUpperCase());
                });
            });
            if(!!duplicatedMethods.length)
            return logger.error(`[Router.register] Route existed (by path and method): [${duplicatedMethods.join('|')}] ${routeObj.path}`);
        }
        registeredRoutes.push(routeObj);
    })
}

let deleteRoutes = routeNames => {
    if(!_.isArray(routeNames)) routeNames = [routeNames];
    registeredRoutes = _.clone(registeredRoutes).filter(routeobj => {
        return !routeNames.includes(routeobj.name);
    });
}

let get = () => {
    return registeredRoutes;
}

/**
 * @description get the index of the route given by name
 * @param {string} routeName
 * @return {integer} index of the route in registeredRoutes array
 */

let getRouteIndexByName = routeName => {
    let routeIndex = _.findIndex(registeredRoutes, routeObj => {
        return routeObj.name == routeName
    });
    return routeIndex;
}

let detach = (routeName, method) => {
    let routeIndex = getRouteIndexByName(routeName);

    if(routeIndex == null) return logger.error(`[Router.detach] Route not found: ${routeName}`);
    if(!registeredRoutes[routeIndex][method]) return logger.error(`[Router.detach] Detach method not found: [${method}] ${routeName}`);
    delete registeredRoutes[routeIndex][method];
}

let attach = (routeName, method, handler) => {
    let routeIndex = _.findIndex(registeredRoutes, routeObj => {
        return routeObj.name == routeName
    });

    if(routeIndex == null) return logger.error(`[Router.detach] Route not found: ${routeName}`);
    if(registeredRoutes[routeIndex][method]) return logger.error(`[Router.detach] Detach method existed: [${method}] ${routeName}, try to detach it first!`);
    registeredRoutes[routeIndex][method] = handler;
}

/**
 * @description attach middware to a route
 * @param {*array of object} middlewareList
 * @return {null} does't return any thing 
 */
let middleware = middlewareList => {
    if(_.isObject(middlewareList)) middlewareList = [middlewareList];
    _.each(middlewareList, mdw => {
        if(!_.isString(mdw.route)) return logger.error('[Router.middleware] invalid middleware route name!');
        let routeIndex = getRouteIndexByName(mdw.route);
        if(routeIndex == null) return logger.error(`[Router.middleware] Route not found: ${mdw.route}`);

        if(!registeredMiddlewares[mdw.route]) {
            registeredMiddlewares[mdw.route] = {};
            _.each(httpMethods, method => registeredMiddlewares[mdw.route][method] = []);
        }
        _.each(httpMethods, method => {
            if(!_.isArray(registeredMiddlewares[mdw.route][method])) registeredMiddlewares[mdw.route][method] = [];
            if(_.isFunction(mdw[method])) registeredMiddlewares[mdw.route][method].push(mdw[method]);
        });
    })
}

let getMiddlewares = () => {
    return registeredMiddlewares;
}

let dispatch = app => {
    let _registeredRoutes = _.map(registeredRoutes, routeObj => {
        if(!_.isNumber(routeObj.priority)) routeObj.priority = 0;
        return routeObj;
    });
    _registeredRoutes = _.sortBy(_registeredRoutes, 'priority').reverse();
    _.each(_registeredRoutes, routeObj => {
        _.each(httpMethods, method => {
            if(_.isFunction(routeObj[method])) {
                // if a route has middleware then call middleware before execute route action;
                if(registeredMiddlewares[routeObj.name] && registeredMiddlewares[routeObj.name][method]) {
                    let routeMiddlewares = _.clone(registeredMiddlewares[routeObj.name][method]);
                    routeMiddlewares.push(routeObj[method]);
                    app[method](routeObj.path, routeMiddlewares);
                }
                else app[method](routeObj.path, routeObj[method]);
            }
        });
    });
};

exports.delete = deleteRoutes;
exports.register = register;
exports.dispatch = dispatch;
exports.get = get;
exports.detach = detach;
exports.attach = attach;
exports.middleware = middleware;
exports.getMiddlewares = getMiddlewares;
exports.registeredRoutes = registeredRoutes;