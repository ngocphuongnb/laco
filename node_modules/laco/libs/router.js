'use strict';

const _ = require('lodash');
const logger = require('./logger');
const httpMethods = ['get', 'post', 'put', 'delete', 'head', 'all', 'patch', 'trace', 'options', 'connect'];

class Router {
    constructor(subapp) {
        this.subapp = subapp;
        this.app = this.subapp.express;
        this.namespace = this.subapp.name;
        this.registeredRoutes = [];
        this.registeredMiddlewares = {};
        this.applicationMiddlewares = {};
        this.registeredParams = {};
        this.routeBase = {
            name: null,
            label: null,
            path: null,
            get: null,
            post: null,
            put: null,
            head: null,
            patch: null,
            trace: null,
            all: null,
            options: null,
            connect: null,
            delete: null,
        }
    }

    /**
     * Register route(s) and it's handler
     * @param {[object]} routeList 
     */
    register(routeList) {
        if (!_.isArray(routeList)) {
            routeList = [routeList];
        }
        _.each(routeList, routeObj => {
            routeObj = _.merge(_.clone(this.routeBase), routeObj);
            if (!routeObj.name ||
                !routeObj.path ||
                (!routeObj.get &&
                    !routeObj.post &&
                    !routeObj.head &&
                    !routeObj.delete &&
                    !routeObj.put &&
                    !routeObj.all
                )
            ) {
                return logger.error(`[Router.register] [${this.namespace}] Invalid route: `, routeObj);
            }

            if (!routeObj.label) {
                routeObj.label = routeObj.name;
            }

            logger.info(`[Router.register] [${this.namespace}] Registering route: \x1b[32m${routeObj.label}\x1b[0m`);
            let checkRoute = _.filter(this.registeredRoutes, {
                name: routeObj.name
            }).length;
            if (checkRoute) {
                return logger.error(`[Router.register]  [${this.namespace}] Route existed (name): ${routeObj.name}`);
            }

            let routesWithSamePath = _.filter(this.registeredRoutes, {
                path: routeObj.path
            });

            if (routesWithSamePath.length) {
                let duplicatedMethods = [];
                _.each(routesWithSamePath, existedRoute => {
                    _.each(httpMethods, method => {
                        if (existedRoute[method] && routeObj[method]) {
                            duplicatedMethods.push(method.toUpperCase());
                        }
                    });
                });
                if (duplicatedMethods.length) {
                    return logger.error(`[Router.register] [${this.namespace}] Route existed (path, method): [${duplicatedMethods.join('|')}] ${routeObj.path}`);
                }
            }
            this.registeredRoutes.push(routeObj);
        });
    }

    /**
     * UnRegister route(s) by it's name
     * @param {[string]} routeNames 
     */
    deleteRoutes(routeNames) {
        if (!_.isArray(routeNames)) {
            routeNames = [routeNames];
        }
        logger.info(`[Router.delete] [${this.namespace}] Deleteing routes: ${routeNames.join(',')}`);
        this.registeredRoutes = _.clone(this.registeredRoutes).filter(routeobj => {
            return !routeNames.includes(routeobj.name);
        });
    }

    get() {
        return this.registeredRoutes;
    }

    /**
     * @description get the index of the route given by name
     * @param {string} routeName
     * @return {integer} index of the route in this.registeredRoutes array
     */

    getRouteIndexByName(routeName) {
        let routeIndex = _.findIndex(this.registeredRoutes, routeObj => {
            return routeObj.name == routeName;
        });
        return routeIndex;
    }

    /**
     * Attach other request method handler to an existed route
     * @param {string} routeName 
     * @param {string} method 
     * @param {function(req, res, next)} handler 
     */
    attach(routeName, method, handler) {
        let routeIndex = _.findIndex(this.registeredRoutes, routeObj => {
            return routeObj.name == routeName;
        });

        if (routeIndex == null) {
            return logger.error(`[Router.attach] [${this.namespace}] Route not found: ${routeName}`);
        }
        if (this.registeredRoutes[routeIndex][method]) {
            return logger.error(`[Router.attach] [${this.namespace}] Attach method existed: [${method}] ${routeName}, try to detach it first!`);
        }
        this.registeredRoutes[routeIndex][method] = handler;
    }

    /**
     * Detach method handler from a route
     * @param {string} routeName 
     * @param {string} method 
     */
    detach(routeName, method) {
        let routeIndex = this.getRouteIndexByName(routeName);

        if (routeIndex == null) {
            return logger.error(`[Router.detach] [${this.namespace}] Route not found: ${routeName}`);
        }
        if (!this.registeredRoutes[routeIndex][method]) {
            return logger.error(`[Router.detach] [${this.namespace}] Detach method not found: [${method}] ${routeName}`);
        }
        delete this.registeredRoutes[routeIndex][method];
    }

    /**
     * App global midlleware, the same as express.use
     */
    use(middlewareList) {
        if (_.isObject(middlewareList)) {
            middlewareList = [middlewareList];
        }
        _.each(middlewareList, mdw => {
            if (!_.isString(mdw.route)) {
                return logger.error('[Router.use] [${this.namespace}] invalid route name!');
            }

            if (!this.applicationMiddlewares[mdw.route]) {
                this.applicationMiddlewares[mdw.route] = [];
            }
            this.applicationMiddlewares[mdw.route].push(mdw.handler);
        });
    }

    /**
     * @description attach middware to a route
     * @param {array of object} middlewareList
     * @return {null} does't return any thing 
     */
    middleware(middlewareList) {
        if (_.isObject(middlewareList)) {
            middlewareList = [middlewareList];
        }
        _.each(middlewareList, mdw => {
            if (!_.isString(mdw.route)) {
                return logger.error('[Router.middleware] [${this.namespace}] invalid route name!');
            }
            let routeIndex = this.getRouteIndexByName(mdw.route);
            if (routeIndex == null) {
                return logger.error(`[Router.middleware] [${this.namespace}] Route not found: ${mdw.route}`);
            }

            if (!this.registeredMiddlewares[mdw.route]) {
                this.registeredMiddlewares[mdw.route] = {};
                _.each(httpMethods, method => this.registeredMiddlewares[mdw.route][method] = []);
            }
            _.each(httpMethods, method => {
                if (!_.isArray(this.registeredMiddlewares[mdw.route][method])) {
                    this.registeredMiddlewares[mdw.route][method] = [];
                }
                if (_.isFunction(mdw[method])) {
                    this.registeredMiddlewares[mdw.route][method].push(mdw[method]);
                }
            });
        });
    }

    getMiddlewares() {
        return this.registeredMiddlewares;
    };

    /**
     * Add handler for a custom params
     * @param {array of object} paramList 
     */
    param(paramList) {
        for (var paramName in paramList) {
            let paramHandler = paramList[paramName];
            if (this.registeredParams[paramName]) {
                logger.error(`[Router.param] [${this.namespace}] Param existed (by name): ${paramName}`);
            } else {
                logger.info(`[Router.param] [${this.namespace}] Success register param handler: ${paramName}`);
                this.registeredParams[paramName] = paramHandler;
            }
        }
    }

    transformHandler(routeHandler) {
        let transformedHandler = null;
        if (_.isFunction(routeHandler)) {
            return routeHandler;
        }

        if (_.isString(routeHandler)) {
            let routeHandlerObj = {
                subapp: this.namespace,
                controller: null,
                action: 'index'
            }

            let routeHandlerParts = routeHandler.split('.');

            if (routeHandlerParts.length == 1) {
                routeHandlerParts.unshift('');
            }
            if (routeHandlerParts[0]) {
                routeHandlerObj.subapp = routeHandlerParts[0];
            }

            let controllerParts = [];
            if (routeHandlerParts[1]) {
                controllerParts = routeHandlerParts[1].split('@');
            }

            if (controllerParts[0]) {
                routeHandlerObj.controller = controllerParts[0];
            }

            if (controllerParts[1]) {
                routeHandlerObj.action = controllerParts[1];
            }

            if (!routeHandlerObj.subapp) {
                return null;
            }

            let laco = this.subapp.laco;
            let handlerSubApp = laco.subAppManager.get(routeHandlerObj.subapp);

            if (!handlerSubApp) {
                logger.error(`[Router.transform] [${this.namespace}] Subapp not found for route: `, routeHandlerObj);
                return null;
            }

            let handlerController = handlerSubApp.app.controller.get(routeHandlerObj.controller);

            if (!handlerController) {
                logger.error(`[Router.transform] [${this.namespace}] Controller not found for route: `, routeHandlerObj);
                return null;
            }

            if (!handlerController[routeHandlerObj.action]) {
                logger.error(`[Router.transform] [${this.namespace}] Action not found for route: `, routeHandlerObj);
                return null;
            }

            return handlerController[routeHandlerObj.action].bind(handlerController);
        }

        return null;
    }

    /**
     * Fire an action to check which route is matched
     * @param {Laco app instance} app 
     */
    dispatch(_app = null) {
        let app = _app || this.app;
        logger.info(`[Router.dispatch] [${this.namespace}] Dispatching...`);


        /**
         * Register application level middlewares
         */

        for (var route in this.applicationMiddlewares) {
            if (route == '*') {
                app.use(this.applicationMiddlewares[route]);
            } else {
                app.use(route, this.applicationMiddlewares[route]);
            }
        }

        let routerNaming = (req, res, next) => {
            let routePattern = (req.route && req.route.path) ? req.route.path : null;
            let routesWithPattern = _.filter(this.registeredRoutes, {
                path: routePattern
            });
            if (!!routesWithPattern.length) {
                req.route = Object.assign(req.route, routesWithPattern[0]);
            }
            next();
        };

        let _registeredRoutes = _.map(this.registeredRoutes, routeObj => {
            if (!_.isNumber(routeObj.priority)) {
                routeObj.priority = 0;
            }
            return routeObj;
        });
        _registeredRoutes = _.sortBy(_registeredRoutes, 'priority').reverse();
        _.each(_registeredRoutes, routeObj => {
            _.each(httpMethods, method => {

                let routeHandlerForMethod = this.transformHandler(routeObj[method]);

                if (_.isFunction(routeHandlerForMethod)) {
                    // if a route has middleware then call middleware before execute route action;
                    if (this.registeredMiddlewares[routeObj.name] && this.registeredMiddlewares[routeObj.name][method]) {
                        let routeMiddlewares = _.clone(this.registeredMiddlewares[routeObj.name][method]);
                        routeMiddlewares.push(routeHandlerForMethod);
                        app[method](routeObj.path, routerNaming, routeMiddlewares);
                    } else {
                        app[method](routeObj.path, routerNaming, routeHandlerForMethod);
                    }
                }
            });
        });

        for (var paramName in this.registeredParams) {
            let paramHandler = this.registeredParams[paramName];
            if (_.isFunction(paramHandler)) {
                app.param(paramName, paramHandler);
            } else logger.error(`[Router.param] [${this.namespace}] Invalid param handler: ${paramName}`, paramHandler);
        }
    }
}

module.exports = Router;