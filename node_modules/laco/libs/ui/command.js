'use strict';

const _ = require('lodash');
const path = require('path');
const async = require('async');
const colors = require('colors');

const gulp = require('gulp');
const gulpSass = require('gulp-sass');
const gulpMinifyCss = require('gulp-minify-css');
const gulpMinifyHtml = require('gulp-minify-html');
const gulpConcat = require('gulp-concat');
const gulpStripDebug = require('gulp-strip-debug');
const gulpUglify = require('gulp-uglify');
const gulpImagemin = require('gulp-imagemin');
const gulpSize = require('gulp-size');

const Command = lacoLib('libs/commander/base');
const taskCommands = require('./task_commands');

class UICommand extends Command {
    constructor(uiManager) {
        super();
        this.name = 'uitask';
        this.label = 'UITaskCommand';
        this.description = 'UITask commands';
        this.uiManager = uiManager;
        this.version = '0.0.1';
        this.gulp = gulp;

        Object.assign(this, {
            gulpSass,
            gulpMinifyCss,
            gulpMinifyHtml,
            gulpConcat,
            gulpStripDebug,
            gulpUglify,
            gulpImagemin,
            gulpSize,
        });

        this.taskCommands = taskCommands;
    }

    exec() {
        this.list();
    }

    invalidUI() {
        return this.error('Invalid ui task, try "./laco uitask list" for complete registered tasks');
    }

    list() {
        this.out();
        this.out('List UI Tasks:\n');
        for (var uiName in this.uiManager.registerdUIs) {
            let ui = this.uiManager.registerdUIs[uiName];
            this.out('  ' + colors.green(uiName).padEnd(40) + 'Run all ui tasks');
            for (var i = 0; i < ui.tasks.length; i++) {
                let task = ui.tasks[i];
                let command = colors.green(uiName) + '@' + colors.yellow(task.name);
                this.out('  ' + command.padEnd(50) + (task.description || ''));
            }
        }
        this.out();
    }

    run(argv) {
        if (!argv.length) {
            return this.invalidUI();
        }

        let argvs = argv[0].split('@');
        let uiName = argvs[0];
        let uiTask = argvs[1] || '';

        let ui = this.uiManager.registerdUIs[uiName] || null;

        if (!ui) {
            return this.invalidUI();
        }

        let tasks = ui.tasks;
        if (uiTask) {
            tasks = _.filter(ui.tasks, task => {
                return task.name == uiTask
            });
        }

        let gulpDest = this.gulp.dest;

        this.gulp.dest = dest => {
            let newDest = path.join(APP_ROOT, 'public/assets', uiName, dest);
            return gulpDest(newDest);
        }

        this.runTasks(ui, tasks);
    }

    runTasks(ui, tasks) {
        if (!_.isArray(tasks)) {
            tasks = [tasks];
        }

        tasks.unshift({
            name: 'default_before',
            description: 'Run default before task',
            cmd: 'before',
            target: ui.name,
        });
        tasks.push({
            name: 'default_after',
            description: 'Run default after task',
            cmd: 'after',
            target: ui.name,
        });

        async.eachLimit(tasks, 1, (task, callback) => {
            this.out(`Running ui task [${colors.green(task.name)}] ${task.description || ''}`);
            if (_.isFunction(task.cmd)) {
                task.cmd(this, task, callback);
            } else if (!this.taskCommands[task.cmd]) {
                callback(`Invalid ui task command: [${task.name}] ` + task.cmd);
            } else {
                task.uiName = ui.name;
                this.taskCommands[task.cmd](task, callback);
            }
        }, err => {
            if (err) {
                console.error(err);
                return this.error('Run tasks error: ', {
                    err,
                    caller: ui.caller
                });
            }
            this.out();
            this.info('UITasks run completed...');
            this.out();
        });
    }
}

module.exports = UICommand;