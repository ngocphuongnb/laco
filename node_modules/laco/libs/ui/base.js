'use strict';

require('marko/node-require');
const _ = require('lodash');
const path = require('path');
const glob = require('glob');
const async = require('async');
const helper = lacoLib('libs/helper');
const logger = lacoLib('libs/logger');
const EventEmitter = lacoLib('libs/EventEmitter');

class UIBase extends EventEmitter {
    constructor(manager, ui, options = {}) {
        super();
        this.manager = manager;
        this.subapp = manager.subapp;
        this.ui = ui;
        let caller = helper.caller();

        this.tasks = [];
        this.layouts = {};
        this.views = {};

        this.options = {
            engine: 'marko',
            viewDir: options.viewDir || path.join(caller.dir, 'views'),
            layoutDir: options.layoutDir || path.join(caller.dir, 'layouts'),
        }

        this.defaultTask = {
            name: null,
            handler: null
        }
    }

    config(options = {}) {
        this.options = _.merge(this.options, options);
    }

    discovery(callback) {
        if (!callback) {
            callback = function() {};
        }

        async.each([this.options.viewDir, this.options.layoutDir], (scanDir, cb) => {
            let target = scanDir == this.options.viewDir ? 'view' : 'layout';
            let action = scanDir == this.options.viewDir ? 'addViews' : 'addLayouts';
            glob(`${scanDir}/**/*.${this.options.engine}`, (err, files) => {
                if (err) {
                    return cb(err);
                }
                files = _.map(files, file => {
                    return file.replace('.' + this.options.engine, '')
                        .replace(this.options[target + 'Dir'], '')
                        .trimChar('/');
                });
                this[action](files);
                cb(null);
            });
        }, err => {
            if (err) {
                logger.error(`[lib.ui.base] [${this.subapp.name}] [${this.ui.name}] Discovery error: `, { task, caller });
            }
            callback(err);
        });
    }

    addTaskes(tasks) {
        let caller = helper.caller();
        if (!_.isArray(tasks)) {
            tasks = [tasks];
        }

        for (var i = 0; i < tasks.length; i++) {
            let task = _.merge(_.clone(this.defaultTask), tasks[i]);

            let taskWithSameName = _.filter(this.tasks, {
                name: task.name
            });

            if (!task.name) {
                logger.error(`[lib.ui.base] [${this.subapp.name}] [${this.ui.name}] Task name cannot be empty! Registered from: `, { task, caller });
            } else if (taskWithSameName) {
                logger.error(`[lib.ui.base] [${this.subapp.name}] [${this.ui.name}] Task name existed: ${task.name} Registered from: `, { task, caller });
            } else if (!_.isFunction(task.handler)) {
                logger.error(`[lib.ui.base] [${this.subapp.name}] [${this.ui.name}] Invalid task handler for: ${task.name} Registered from: `, { task, caller });
            } else {
                logger.info(`[lib.ui.base] [${this.subapp.name}] [${this.ui.name}] Registering UI task: ${task.name}`);
                this.tasks.push(new task.handler(this, task));
            }
        }
    }

    addLayouts(layouts) {
        if (!_.isArray(layouts)) {
            layouts = [layouts];
        }

        for (var i in layouts) {
            let layoutName = layouts[i];
            let layoutPath = path.join(this.options.layoutDir, layoutName);

            if (helper.isFileExisted(layoutPath)) {
                logger.info(`[lib.ui.addLayou] [${this.subapp.name}] [${this.ui.name}] Registering layout: ${layoutName}`);
                layoutName = layoutName.replace(/\//gim, '.');
                this.layouts[layoutName] = require(layoutPath);
            } else {
                let caller = helper.caller();
                logger.error(`[lib.ui.addLayou] [${this.subapp.name}] [${this.ui.name}] Layout not found: `, { layoutPath, caller });
            }
        }
    }

    addViews(views) {
        if (!_.isArray(views)) {
            views = [views];
        }

        for (var i in views) {
            let viewName = views[i];
            let viewPath = path.join(this.options.viewDir, viewName);

            if (helper.isFileExisted(viewPath)) {
                logger.info(`[lib.ui.addViews] [${this.subapp.name}] [${this.ui.name}] Registering view: ${viewName}`);
                viewName = viewName.replace(/\//gim, '.');
                this.views[viewName] = require(viewPath);
            } else {
                let caller = helper.caller();
                logger.error(`[lib.ui.addViews] [${this.subapp.name}] [${this.ui.name}] View not found: `, { viewPath, caller });
            }
        }
    }
}

module.exports = UIBase;