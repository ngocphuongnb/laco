'use strict';

const _ = require('lodash');
const logger = require('./logger');

const httpMethods = ['get', 'post', 'put', 'delete', 'head', 'all', 'patch', 'trace', 'options', 'connect'];
let registeredRoutes = [];
let registeredMiddlewares = {};
let registeredParams = {};

/**
 * Register route(s) and it's handler
 * @param {[object]} routeList 
 */
let register = routeList => {
    if (!_.isArray(routeList)) {
        routeList = [routeList];
    }
    _.each(routeList, routeObj => {
        if (
            !routeObj.label ||
            !routeObj.name ||
            !routeObj.path ||
            (
                !routeObj.get &&
                !routeObj.post &&
                !routeObj.head &&
                !routeObj.delete &&
                !routeObj.put &&
                !routeObj.all
            )
        ) {
            return logger.error('[Router.register] Invalid route: ', routeObj);
        }

        logger.info(`[Router.register] Registering route: \x1b[32m${routeObj.label}\x1b[0m`);
        let checkRoute = _.filter(registeredRoutes, { name: routeObj.name }).length;
        if (checkRoute) {
            return logger.error(`[Router.register] Route existed (name): ${routeObj.name}`);
        }

        let routesWithSamePath = _.filter(registeredRoutes, {
            path: routeObj.path
        });
        if (routesWithSamePath.length) {
            let duplicatedMethods = [];
            _.each(routesWithSamePath, existedRoute => {
                _.each(httpMethods, method => {
                    if (existedRoute[method] && routeObj[method]) {
                        duplicatedMethods.push(method.toUpperCase());
                    }
                });
            });
            if (duplicatedMethods.length) {
                return logger.error(`[Router.register] Route existed (path, method): [${duplicatedMethods.join('|')}] ${routeObj.path}`);
            }
        }
        registeredRoutes.push(routeObj);
    });
};

/**
 * UnRegister route(s) by it's name
 * @param {[string]} routeNames 
 */
let deleteRoutes = routeNames => {
    if (!_.isArray(routeNames)) {
        routeNames = [routeNames];
    }
    logger.info(`[Router.delete] Deleteing routes: ${routeNames.join(',')}`);
    registeredRoutes = _.clone(registeredRoutes).filter(routeobj => {
        return !routeNames.includes(routeobj.name);
    });
};

let get = () => {
    return registeredRoutes;
};

/**
 * @description get the index of the route given by name
 * @param {string} routeName
 * @return {integer} index of the route in registeredRoutes array
 */

let getRouteIndexByName = routeName => {
    let routeIndex = _.findIndex(registeredRoutes, routeObj => {
        return routeObj.name == routeName;
    });
    return routeIndex;
};

/**
 * Attach other request method handler to an existed route
 * @param {string} routeName 
 * @param {string} method 
 * @param {function(req, res, next)} handler 
 */
let attach = (routeName, method, handler) => {
    let routeIndex = _.findIndex(registeredRoutes, routeObj => {
        return routeObj.name == routeName;
    });

    if (routeIndex == null) {
        return logger.error(`[Router.attach] Route not found: ${routeName}`);
    }
    if (registeredRoutes[routeIndex][method]) {
        return logger.error(`[Router.attach] Attach method existed: [${method}] ${routeName}, try to detach it first!`);
    }
    registeredRoutes[routeIndex][method] = handler;
};

/**
 * Detach method handler from a route
 * @param {string} routeName 
 * @param {string} method 
 */
let detach = (routeName, method) => {
    let routeIndex = getRouteIndexByName(routeName);

    if (routeIndex == null) {
        return logger.error(`[Router.detach] Route not found: ${routeName}`);
    }
    if (!registeredRoutes[routeIndex][method]) {
        return logger.error(`[Router.detach] Detach method not found: [${method}] ${routeName}`);
    }
    delete registeredRoutes[routeIndex][method];
};

/**
 * @description attach middware to a route
 * @param {array of object} middlewareList
 * @return {null} does't return any thing 
 */
let middleware = middlewareList => {
    if (_.isObject(middlewareList)) {
        middlewareList = [middlewareList];
    }
    _.each(middlewareList, mdw => {
        if (!_.isString(mdw.route)) {
            return logger.error('[Router.middleware] invalid route name!');
        }
        let routeIndex = getRouteIndexByName(mdw.route);
        if (routeIndex == null) {
            return logger.error(`[Router.middleware] Route not found: ${mdw.route}`);
        }

        if (!registeredMiddlewares[mdw.route]) {
            registeredMiddlewares[mdw.route] = {};
            _.each(httpMethods, method => registeredMiddlewares[mdw.route][method] = []);
        }
        _.each(httpMethods, method => {
            if (!_.isArray(registeredMiddlewares[mdw.route][method])) {
                registeredMiddlewares[mdw.route][method] = [];
            }
            if (_.isFunction(mdw[method])) {
                registeredMiddlewares[mdw.route][method].push(mdw[method]);
            }
        });
    });
};

let getMiddlewares = () => {
    return registeredMiddlewares;
};

/**
 * Add handler for a custom params
 * @param {array of object} paramList 
 */
let param = paramList => {
    for (var paramName in paramList) {
        let paramHandler = paramList[paramName];
        if (registeredParams[paramName]) {
            logger.error(`[Router.param] Param existed (by name): ${paramName}`);
        }
        else {
            logger.info(`[Router.param] Success register param handler: ${paramName}`);
            registeredParams[paramName] = paramHandler;
        }
    }
}

/**
 * Fire an action to check which route is matched
 * @param {Laco app instance} app 
 */
let dispatch = app => {
    logger.info(`[Router.dispatch] Dispatching...`)
    let routerNaming = (req, res, next) => {
        let routePattern = (req.route && req.route.path) ? req.route.path : null;
        let routesWithPattern = _.filter(registeredRoutes, {
            path: routePattern
        });
        if (!!routesWithPattern.length) {
            req.route = Object.assign(req.route, routesWithPattern[0]);
        }
        next();
    };

    let _registeredRoutes = _.map(registeredRoutes, routeObj => {
        if (!_.isNumber(routeObj.priority)) {
            routeObj.priority = 0;
        }
        return routeObj;
    });
    _registeredRoutes = _.sortBy(_registeredRoutes, 'priority').reverse();
    _.each(_registeredRoutes, routeObj => {
        _.each(httpMethods, method => {
            if (_.isFunction(routeObj[method])) {
                // if a route has middleware then call middleware before execute route action;
                if (registeredMiddlewares[routeObj.name] && registeredMiddlewares[routeObj.name][method]) {
                    let routeMiddlewares = _.clone(registeredMiddlewares[routeObj.name][method]);
                    routeMiddlewares.push(routeObj[method]);
                    app[method](routeObj.path, routerNaming, routeMiddlewares);
                } else {
                    app[method](routeObj.path, routerNaming, routeObj[method]);
                }
            }
        });
    });


    for (var paramName in registeredParams) {
        let paramHandler = registeredParams[paramName];
        if (_.isFunction(paramHandler)) {
            app.param(paramName, paramHandler);
        } else logger.error(`[Router.param] Invalid param handler: ${paramName}`, paramHandler);
    }
};

exports.delete = deleteRoutes;
exports.register = register;
exports.dispatch = dispatch;
exports.get = get;
exports.detach = detach;
exports.attach = attach;
exports.middleware = middleware;
exports.getMiddlewares = getMiddlewares;
exports.param = param;
exports.registeredRoutes = registeredRoutes;