'use strict';

const _ = require('lodash');
const helper = lacoLib('libs/helper');
const logger = lacoLib('libs/logger');
let db = require('./models/db');

const getConversationsByUserId = userId => {
    return new Promise((resolve, reject) => {
        db.models.conversation.find({
            $or: [
                { creatorid: userId },
                { targetid: userId },
            ]
        }).lean().exec().then(conversations => {
            let conversationUsers = [];
            _.each(conversations, conversation => {
                conversationUsers = _.union(conversationUsers, [conversation.creatorid, conversation.targetid]);
            });

            conversations = _.map(conversations, conversation => {
                conversation.identity = helper.encrypt2(conversation.intId.toString());
                delete conversation._id;
                // delete conversation.intId;
                delete conversation.__v;
                return conversation;
            });

            let getUsers = db.models.user.find({ userid: { $in: conversationUsers } }).lean().exec();
            getUsers.then(users => {
                users = _.map(users, user => {
                    user.identity = helper.encrypt2(user.intId.toString());
                    delete user._id;
                    delete user.intId;
                    delete user.__v;
                    return user;
                });

                users = _.chain(users).keyBy('userid').value();

                conversations = _.map(conversations, conversation => {
                    let chatUserId = conversation.creatorid == userId ? conversation.targetid : conversation.creatorid;
                    let chatUser = users[chatUserId];
                    conversation.name = chatUser.fullname || chatUser.username;
                    conversation.sender_name = helper.encrypt2(users[userId].fullname || users[userId].username);
                    return conversation;
                });

                return resolve({ userIdentity: helper.encrypt2(userId.toString()), conversations, users, me: userId });
            }).catch(err => {
                logger.error('[ext.homejobchat] Cannot get conversation users:', err);
                return reject('Cannot get conversation users');
            });
        }).catch(err => {
            logger.error('[ext.homejobchat] Cannot get user conversations:', err);
            return reject('Cannot get user conversations');
        });
    });
}

exports.getConversationsByUserId = getConversationsByUserId;