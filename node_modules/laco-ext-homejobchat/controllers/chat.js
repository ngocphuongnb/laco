'use strict';

const _ = require('lodash');
const BaseController = lacoLib('libs/controller/base');
const helper = lacoLib('libs/helper');
const logger = lacoLib('libs/logger');
const db = require('../models/db');

class Chat extends BaseController {
    constructor(manager, controller) {
        super(manager, controller);
    }

    index(req, res, next) {
        let currentUserId = parseInt(req.query.user) || 112;
        this.getConversationsByUserId(currentUserId).then(data => {
            let users = data.users || {};
            let conversations = data.conversations || [];
            let currentUser = users[currentUserId];

            let conversionTpls = [];
            _.each(conversations, conversation => {
                conversionTpls.push(`<li><span class="hjchat-conversation-trigger" data-identity="${conversation.identity}">${conversation.name}</span></li>`)
            });
            res.end(`<!doctype html>
<html>
    <head>
        <title>Socket.IO chat</title>
        <style>
            * { margin: 0; padding: 0; box-sizing: border-box; }
            body { font: 13px Helvetica, Arial; }

            html,body,.hjchat-conversation-list,.hjchat-conversation-container {
                height: 100%
            }

            .hjchat-conversation-list {
                width: 300px;
                background: #f1f1f1;
                float: left;
            }

            .hjchat-conversation-container {
                width: Calc(100% - 900px);
                background: #FFF;
                float: left;
            }

            .hjchat-msg-wrapper {
                height: Calc(100% - 40px);
            }

            .hjchat-conversation-trigger {
                padding: 5px 10px;
                font-size: 14px;
                display: block;
                background: #e2e2e2;
                cursor: pointer;
            }

            .hjchat-conversation-trigger:hover,.hjchat-conversation-trigger.active {
                background: #353535;
                color: #FFF;
            }

            .hjchat-conversation-item {
                padding: 20px;
                height: 100%;
                overflow-y: auto;
            }

            .hjchat-conversation-item .hjchat-msgs {
                list-style: none
            }

            ul.hjchat-msgs li {
                position: relative;
                margin-bottom: 20px;
            }
            
            span.hj-chat-user {
                display: block;
                font-weight:  700;
                font-size: 18px;
                margin-bottom:  10px;
                color: #008686;
            }
            
            span.hj-chat-msg-content {
                font-size: 18px;
            }
            
            .hj-chat-meta {
                position: absolute;
                top: 0;
                right: 10px;
                color: #545454
            }

            .hjchat-form { background: #000; padding: 3px; width: 100%; height:40px }
            .hjchat-input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }
            .hjchat-submit { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }
            #messages { list-style-type: none; margin: 0; padding: 0; }
            #messages li { padding: 5px 10px; }
            #messages li:nth-child(odd) { background: #eee; }
        </style>
        <script>
            window.hjChatUserIdentity = '${data.userIdentity}';
            window.hjChatPreloadedUsers = ${JSON.stringify(users, null, 4)};
            window.hjMsgLoadEndpoint = '/chat/msg';
        </script>
    </head>
    <body>
        <ul class="hjchat-conversation-list">
            ${conversionTpls.join('\n')}
        </ul>

        <div class="hjchat-conversation-container">
            <div class="hjchat-msg-wrapper">
                <div class="hjchat-msg-template">
                    <ul class="hjchat-msgs"></ul>
                </div>
            </div>

            <form action="" class="hjchat-form">
                <input class="hjchat-input" autocomplete="off" />
                <input type="submit" class="hjchat-submit" value="Send" />
            </form>
        </div>
        
        <script src="https://code.jquery.com/jquery-1.11.1.js"></script>
        <script src="/socket/socket.io.js"></script>
        <script src="/assets/HJAsset/js/chat.min.js"></script>
    </body>
</html>`);
        }).catch(e => res.end(e));
    }


    getMsg(req, res) {
        let identity = req.body.identity || null;
        let userIdt = req.body.userIdt || null;

        let conversationId = null;
        let userId = null;

        try {
            conversationId = parseInt(helper.decrypt2(identity));
            userId = parseInt(helper.decrypt2(userIdt));
        } catch (e) {}

        if (!conversationId || !userId) {
            return res.json({ status: 0, msg: 'Invalid identity' })
        }

        db.models.message.find({ conversationid: conversationId })
            .sort({ 'created_date': -1 })
            .limit(40)
            .lean()
            .exec()
            .then(msgs => {
                res.json({
                    status: 1,
                    data: msgs.reverse()
                })
            })
            .catch(err => {
                res.json({
                    status: 0,
                    msg: 'Cannot get messages!'
                })
            })

    }

    user(req, res) {}

    createUser(req, res) {
        let userInfo = {
            userid: req.body.userid ? parseInt(req.body.userid) : null,
            username: req.body.username || null,
            type: req.body.type && ['worker', 'employer'].indexOf(req.body.type) > -1 ? req.body.type : null,
            fullname: req.body.fullname || null,
            image: req.body.image || null,
            created_date: new Date(),
        }

        if (!userInfo.userid || !userInfo.username || !userInfo.type) {
            return res.json({
                status: 0,
                msg: 'Userid, username and type are required'
            });
        }

        let saveUser = new db.models.user(userInfo);
        let isUpdating = req.body.update && parseInt(req.body.update) == 1 ? true : false;

        if (isUpdating) {
            userInfo.updated_date = new Date();
            delete userInfo.created_date;
            saveUser = db.models.user.update({ userid: userInfo.userid }, { $set: userInfo }).exec();
        } else {
            saveUser = saveUser.save();
        }

        saveUser.then(user => res.json({ status: 1 }))
            .catch(err => {
                logger.error('[ext.homejobchat] Cannot save user:', { err, userInfo });
                res.json({ status: 0, msg: 'Cannot save user!' });
            });
    }

    getConversationsByUserId(userId) {
        return new Promise((resolve, reject) => {
            db.models.conversation.find({
                $or: [
                    { creatorid: userId },
                    { targetid: userId },
                ]
            }).lean().exec().then(conversations => {
                let conversationUsers = [];
                _.each(conversations, conversation => {
                    conversationUsers = _.union(conversationUsers, [conversation.creatorid, conversation.targetid]);
                });

                conversations = _.map(conversations, conversation => {
                    conversation.identity = helper.encrypt2(conversation.intId.toString());
                    delete conversation._id;
                    // delete conversation.intId;
                    delete conversation.__v;
                    return conversation;
                });

                let getUsers = db.models.user.find({ userid: { $in: conversationUsers } }).lean().exec();
                getUsers.then(users => {
                    users = _.map(users, user => {
                        user.identity = helper.encrypt2(user.intId.toString());
                        delete user._id;
                        delete user.intId;
                        delete user.__v;
                        return user;
                    });

                    users = _.chain(users).keyBy('userid').value();

                    conversations = _.map(conversations, conversation => {
                        let chatUserId = conversation.creatorid == userId ? conversation.targetid : conversation.creatorid;
                        let chatUser = users[chatUserId];
                        conversation.name = chatUser.fullname || chatUser.username;
                        return conversation;
                    });

                    return resolve({ userIdentity: helper.encrypt2(userId.toString()), conversations, users });
                }).catch(err => {
                    logger.error('[ext.homejobchat] Cannot get conversation users:', err);
                    return reject('Cannot get conversation users');
                });
            }).catch(err => {
                logger.error('[ext.homejobchat] Cannot get user conversations:', err);
                return reject('Cannot get user conversations');
            });
        });
    }

    conversation(req, res) {
        let userId = req.query.userid ? parseInt(req.query.userid) : null;
        if (!userId) {
            return res.json({
                status: 0,
                msg: 'UserId is required'
            });
        }

        this.getConversationsByUserId(userId).then(data => res.json({ status: 1, data }))
            .catch(err => res.json({ status: 0, msg: err }));
    }

    createConversation(req, res) {
        let conversationInfo = {
            creatorid: req.body.creatorid ? parseInt(req.body.creatorid) : null,
            targetid: req.body.targetid ? parseInt(req.body.targetid) : null,
            created_date: new Date(),
        }

        if (!conversationInfo.creatorid || !conversationInfo.targetid) {
            return res.json({
                status: 0,
                msg: 'CreatorId, and targetid are required'
            });
        }
        conversationInfo.identity = conversationInfo.creatorid + '_' + conversationInfo.targetid;

        let saveConversation = new db.models.conversation(conversationInfo);
        let isUpdating = req.body.update && parseInt(req.body.update) == 1 ? true : false;

        if (isUpdating) {
            conversationInfo.updated_date = new Date();
            delete conversationInfo.created_date;
            saveConversation = db.models.conversation.update({ identity: conversationInfo.identity }, { $set: conversationInfo }).exec();
        } else {
            saveConversation = saveConversation.save();
        }

        saveConversation.then(conv => res.json({ status: 1 }))
            .catch(err => {
                logger.error('[ext.homejobchat] Cannot save conversation:', { err, conversationInfo });
                res.json({ status: 0, msg: 'Cannot save conversation!' });
            });
    }
}

//php example
// define('AES_METHOD', 'aes-256-cbc');

// function encrypt($message, $password)
// {
//     // Check versions with Heartbleed vulnerabilities
//     if (OPENSSL_VERSION_NUMBER <= 268443727) {
//         throw new RuntimeException('OpenSSL Version too old');
//     }

//     $iv_size        = openssl_cipher_iv_length(AES_METHOD);
//     $iv             = openssl_random_pseudo_bytes($iv_size);
//     $ciphertext     = openssl_encrypt($message, AES_METHOD, $password, OPENSSL_RAW_DATA, $iv);
//     $ciphertext_hex = bin2hex($ciphertext);
//     $iv_hex         = bin2hex($iv);

//     return "$iv_hex:$ciphertext_hex";
// }

// function decrypt($ciphered, $password) {
//     $iv_size    = openssl_cipher_iv_length(AES_METHOD);
//     $iv         = mb_substr($ciphered, 0, $iv_size, '8bit');
//     $ciphertext = mb_substr($ciphered, $iv_size+1, strlen($ciphered), '8bit');

//     return openssl_decrypt($ciphertext, AES_METHOD, $password, OPENSSL_RAW_DATA, $iv);
// }

// echo encrypt($message, $key);
module.exports = Chat;